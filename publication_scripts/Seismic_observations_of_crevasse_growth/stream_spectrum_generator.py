#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Spectrum generator for day-long stream files
of a single component at a single station.
"""

# Import packages

import math
import numpy as np
import obspy
import os
import threading




def generate_spectra(midtime, substream, sampling_rate, thread):
    
    '''
    Use i (CPU #) and c (# spectra generated by the CPU) to
    generate spectra for a data window and save it to a list
    unique for the CPU.
    v2 - do this outside of the function
    '''
    
    global spectrum_list               
    
    # Generate spectra
    
    try:
        
        spectrum = np.fft.fft(substream)
                           
        # Save spectrum and metadata (only up to nyquist frequency)
    
        spectrum_list[thread].append(midtime, spectrum[:int(sampling_rate / 2) + 1])
        
    except:
        
        pass




def process(year, doy, station, stream_file, FFT_window_length, FFT_window_overlap, numthreads):
    
            '''
            Calculate spectra for stream
            '''
                                
            print('Processing stream for station ' + station + ' on day ' + str(doy) + ' in ' + str(year))

            # Load the data as an obspy stream object
            # and determine its sampling rate and
            # length in FFT windows
        
            stream = obspy.read(stream_file)
            
            sampling_rate = stream[0].stats.sampling_rate                
            
            num_windows = int(float(1 / (1 - FFT_window_overlap)) * \
                          (len(stream[0].data) / sampling_rate) / float(FFT_window_length))
            
            start_time = stream[0].stats.starttime
            
            # Filter the stream to remove data that is unresolvable
            # with the given FFT window length
            
            stream.filter('highpass', freq = 1 / float(FFT_window_length))
            
            # Split the stream into windows and calculate their spectra,
            # encorporating window overlap
                      
            # First generate the substreams
            
            midtimes = [[] for j in range(num_windows)]
            substreams = [[] for j in range(num_windows)]
            
            print('Separating stream into substreams for FFT calculation')
            
            for j in range(num_windows):
            
                # Calculate window midtime
                
                midtime = start_time + (j) * (1 - FFT_window_overlap) * FFT_window_length + 0.5 * FFT_window_length
                
                # Trim stream to window
                
                substream = stream.copy()
                substream.trim(starttime = start_time + j * (1 - FFT_window_overlap) * FFT_window_length, 
                               endtime = start_time + j * (1 - FFT_window_overlap) * FFT_window_length + FFT_window_length
                               - 1 / float(sampling_rate))
                               
                # Demean and detrend data in window
                               
                substream.detrend(type = 'demean')
                substream.detrend(type = 'simple')
                
                midtimes[j]= midtime
                substreams[j] = substream[0].data
        
            # Now generate the stream spectra using multithreading
            
            spectrum_list = [[] for i in range(numthreads)]
            
            count = 0
            threads = [[] for i in range(numthreads)]
            
            print('Calculating substream spectra')
            
            while count <= (int(math.ceil(num_windows / numthreads))):    
                
                for thread in range(numthreads):
                    
                    # Generate j variable: the index of the data window to process

                    j = thread + (count * numthreads)
                    
                    # Get data from lists
                    
                    try:
                        
                        midtime = midtimes[j]
                        substream = substreams[j]
                        
                    except:
                        
                        break
                    
                    # Do FFT
                  
                    p = threading.Thread(target = generate_spectra, args = (midtime, substream, sampling_rate, thread, ))
                    threads[thread] = p
                    p.start()
                
                for thread in threads:
                
                    thread.join()
                    
                # Once all jobs complete, increment the count
                    
                count += 1

            # Save spectrum to disk                            
                            
            spectrums_array = np.array(spectrum_list)
            np.save(os.getcwd() + '/' + str(stream_file.split('/')[-1]) + '_spectrums_v1', spectrums_array)