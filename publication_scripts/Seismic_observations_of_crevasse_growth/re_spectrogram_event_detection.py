#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Take spectrogram-detected events and redefine trigger times
by recalculating spectrograms at higher temporal resolution
(and hence lower frequency resolution).
"""

# Literally just copy and paste the spectrogram generation script

import datetime
import glob
import os
import concurrent.futures

import math
import numpy as np
import obspy
import threading

import obspy
import matplotlib.pyplot as plt

def generate_spectra(starttime, substream, sampling_rate, thread):
    
    '''
    Use i (CPU #) and c (# spectra generated by the CPU) to
    generate spectra for a data window and save it to a list
    unique for the CPU.
    v2 - do this outside of the function
    '''
    
    global spectrum_list               
    
    # Generate spectra
    
    try:
        
        spectrum = np.fft.fft(substream)
                           
        # Save spectrum and metadata (only up to nyquist frequency)
    
        spectrum_list[thread].append([starttime, spectrum[:int(sampling_rate / 2) + 1]])
        
    except:
        
        pass




def spectra_generator(stream):
    
    '''
    Calculate spectra for stream. All variables bar stream_file
    are defined prior to the function call.
    '''
    
    global spectrum_list

    # Load the data as an obspy stream object
    # and determine its sampling rate and
    # length in FFT windows
    
    sampling_rate = stream[0].stats.sampling_rate    
    station = stream[0].stats.station            
    
    # Filter the stream to remove data that is unresolvable
    # with the given FFT window length
    
#    stream.filter('highpass', freq = 1 / float(FFT_window_length))
    
    start_time = stream[0].stats.starttime
    end_time = stream[0].stats.endtime
    
    # Remove pre and post event time from the stream

    stream.trim(starttime = start_time + pre_post_time - old_FFT_window,
                endtime = end_time - pre_post_time + old_FFT_window)

    start_time = stream[0].stats.starttime    
    num_windows = int((len(stream[0].data) / sampling_rate) / float(FFT_window_length))
    
    # Split the stream into windows and calculate their spectra,
    # encorporating window overlap
              
    # First generate the substreams
    
    starttimes = [[] for j in range(num_windows)]
    substreams = [[] for j in range(num_windows)]
    
    print('Separating stream into substreams for FFT calculation')

    for j in range(num_windows):
    
        # Calculate window start time
        
        starttime = start_time + (j) * FFT_window_length 
        
        # Trim stream to window
        
        substream = stream.copy()
        substream.trim(starttime = start_time + j * FFT_window_length, 
                       endtime = start_time + j * FFT_window_length + FFT_window_length)
                       
        # Demean and detrend data in window
                       
        substream.detrend(type = 'demean')
        substream.detrend(type = 'simple')
        
        starttimes[j]= starttime
        substreams[j] = substream[0].data

    # Now generate the stream spectra using multithreading
    
    spectrum_list = [[] for i in range(numthreads)]
    
    count = 0
    threads = [[] for i in range(numthreads)]
    
    print('Calculating substream spectra')
    
    while count <= (int(math.ceil(num_windows / numthreads))):    
        
        for thread in range(numthreads):
            
            # Generate j variable: the index of the data window to process

            j = thread + (count * numthreads)
            
            # Get data from lists
            
            try:
            
                starttime = starttimes[j]
                substream = substreams[j]
                
            except:
                
                break
            
            # Do FFT
          
            p = threading.Thread(target = generate_spectra, args = (starttime, substream, sampling_rate, thread, ))
            threads[thread] = p
            p.start()
        
        for thread in threads:
        
            thread.join()
            
        # Once all jobs complete, increment the count
            
        count += 1
        
        # As the while ... else logic doesn't seem to work,
        # just use an if statement (slow, but functional)
        
        if count == (int(math.ceil(num_windows / numthreads))):
            
            # Save spectrum to disk                            
            
            spectrums_array = np.array(spectrum_list)
            np.save(event_output_directory + event[:-6] + '_' + str(station) + '_spectrums', spectrums_array)




#!#!#!#!# PARAMETERS AND CONTROL CODE FOR SPECTRUM RE-GENERATION #!#!#!#!#

## Event input directory
            
event_input_directory = '/home/sam/EVENTS_IT3/TYPE_A/4/'

## Event output directory is where spectrums are saved
## Spectrum directory is where spectrums are loaded from

event_output_directory = event_input_directory
spectrum_directory = event_input_directory

## Set FFT window length (seconds)
## Note: minimum detectable frequency is 1/FFT_window_length

FFT_window_length = 50 / 250
old_FFT_window = 1

## Number of CPUs to use for multithreading

numthreads = 1

#!#!#!#!# PARAMETERS AND CONTROL CODE FOR SPECTROGRAM RE-DETECTION #!#!#!#!#
        
stations = ['TSNC1', 'TSNC3', 'TSNL2', 'TSNL3', 'TSNR2', 'TSNR3']

## NOTE: set these as the same as the original detection, but adjust for
## timing differences due to shorter FFT windows

## Set signal and noise frequency band start/finish indices
## NOTE: use numpy.fftfftfreq() to see frequency bins for given FFT parameters

signal_bands = [[0, 5]]
noise_bands = signal_bands

## Set number of cells to sample for each band's calculation

noise_samples = 1
signal_samples = 1

## Set weighting for each band

signal_band_weights = [1]
noise_band_weights = [2]

## Set threshold required to trigger detection consideratio

trigger_threshold = 2
trigger_dethreshold = 1
trigger_overload = 999999

## Set pre and post event time (s) for event files
## (here this is used to cut the data to the region surrounding the event)

pre_post_time = 10

# Load events

files = os.listdir(event_input_directory)
events = []
for afile in files:
    if afile[-6:] == '.MSEED':
        events.append(afile)
        
# Reshape event stream to function with pre-existing spectrum generation code
        
#for event in events:
#        
#    stream = obspy.read(event_input_directory +  event)
#    
#    streams_to_process = []
#    for trace in stream:
#        tracestream = obspy.Stream()
#        tracestream += trace
#        streams_to_process.append(tracestream)
#        
#    # Generate spectra for each event
#
#    print('Regenerating spectra for event ' + event)
#    print(streams_to_process)
#    
#    with concurrent.futures.ProcessPoolExecutor() as executor:
#    
#        executor.map(spectra_generator, streams_to_process)
                
        
        
# Generate trigger times

for event in events:

#            if event not in ['2016-04-21T05:42:16.500000Z.MSEED']: continue
            
            spectrum_files = glob.glob(spectrum_directory + event[:-6] + '*spectrums.npy')
                        
            # Apply component and station filtering

            triggers = []
            band_ratios = [[] for i in range(len(stations))]
            
            for spectrum_file in spectrum_files:
                
                stream_file_metadata = spectrum_file.split('/')[-1].split('_')
                station = stream_file_metadata[-2]
                
                # Load the spectrum file
            
                spectrum_list = np.load(spectrum_file).tolist()
                
                # Join spectra lists together
                
                times = []
                spectrums = []
                for i in range(len(spectrum_list)):
                    for j in range(len(spectrum_list[i])):
                        if len(spectrum_list[i][j]) > 0:
                            times.append([])
                            spectrums.append([])
                            times[-1] = (spectrum_list[i][j][0])
                            # Miss the first frequency entry as it is not representative of
                            # particular harmonics.
                            spectrums[-1] = np.absolute(spectrum_list[i][j][1][1:].real)
                            
                # Ensure times are chronological
                # Unsorting may result from multithreading during spectrum generation
                times, spectrums = zip(*sorted(zip(times, spectrums)))
                
                times = np.array(times)
                spectrums = np.array(spectrums)
                
                spectrum_band_ratios = [0 for j in range(len(spectrums))]
                
                # Calculate trigger section:
                
                print('Generating triggers for station ' + station + ' in event ' + event)
                
                trigger_on = False
                
                # Generate first noise value
                
                noise = 0
                
                for n in range(noise_samples):
                
                    for noise_band in noise_bands:
                            
                        if len(noise_band) > 1:
                        
                            noise += sum(abs(spectrums[n][noise_band[0] : noise_band[1]])) * noise_band_weights[noise_bands.index(noise_band)] \
                                    / (noise_band[1] - noise_band[0])
                            
                        else:
                            
                            noise += abs(spectrums[n][noise_band[0]]) * noise_band_weights[noise_bands.index(noise_band)]
                            
                # Compare signal values to noise values and generate triggers
                # Each signal value is compared to the previous "signal" value
                # (noise value) until the signal/noise threshold is passed,
                # at this point each successive signal value is compared to
                # the noise value at the time of triggering. This allows long
                # triggers to occur which is useful for separating different
                # spectral signatures.
                
                j = (noise_samples - 1)
                
                while (j < (len(spectrums) - 1)):
                    
                    j += 1
                    
                    starttime = times[j]
                    
                    # Calculate band ratios (normalise by length of band)
                    
                    signal = 0
                    
                    for s in range(signal_samples):
                        
                        s = j + s
                        
                        for signal_band in signal_bands:
                            
                            if len(signal_band) > 1:
                        
                                signal += sum(abs(spectrums[s][signal_band[0] : signal_band[1]])) * signal_band_weights[signal_bands.index(signal_band)] \
                                        / (signal_band[1] - signal_band[0])
                            
                            else:
                            
                                signal += abs(spectrums[s][signal_band[0]]) * signal_band_weights[signal_bands.index(signal_band)]
                    
                    try:
                        
                        band_ratio = signal / noise
                        spectrum_band_ratios[j] = band_ratio
                        
                    except:
                        
                        print('Signal:noise calculation failed at index ' + str(j) + ' !')
                        continue
                    
                    # Determine and save triggers

                    if ((trigger_on == False) and (trigger_overload > band_ratio >= trigger_threshold)):

                        trigger_on = True    
                        trigger_on_index = j - 1
                        
                    elif ((trigger_on == True) and (band_ratio < trigger_dethreshold)):

                        trigger_on = False
                        trigger_off_index = j
                        triggers.append([times[trigger_on_index],
                                         times[trigger_off_index],
                                         station,
                                         trigger_on_index,
                                         trigger_off_index])   
    
                        # Reset j to allow overlapping triggers
    
                        j = trigger_on_index + 1
                        
                        # Reset noise to the value at the trigger on index
                                
                        noise = 0
                        
                        for n in range(noise_samples):
                        
                            n = j - n
                            
                            for noise_band in noise_bands:
                                    
                                if len(noise_band) > 1:
                                
                                    noise += sum(abs(spectrums[n][noise_band[0] : noise_band[1]])) * noise_band_weights[noise_bands.index(noise_band)] \
                                            / (noise_band[1] - noise_band[0])
                                    
                                else:
                                    
                                    noise += abs(spectrums[n][noise_band[0]]) * noise_band_weights[noise_bands.index(noise_band)]
                        
                    elif ((trigger_on == True) and (j == (len(spectrums) - 1))):

                        # When trigger_off is very low, allow the code to work
                        
                        trigger_on = False
                        trigger_off_index = j
                        triggers.append([times[trigger_on_index],
                                         times[trigger_off_index],
                                         station,
                                         trigger_on_index,
                                         trigger_off_index])   
    
                         # Reset j to allow overlapping triggers
    
                        j = trigger_on_index + 1   
                        
                        # Reset noise to the value at the trigger on index
                        
                        noise = 0
                        
                        for n in range(noise_samples):
                        
                            n = j - n
                            
                            for noise_band in noise_bands:
                                    
                                if len(noise_band) > 1:
                                
                                    noise += sum(abs(spectrums[n][noise_band[0] : noise_band[1]])) * noise_band_weights[noise_bands.index(noise_band)] \
                                            / (noise_band[1] - noise_band[0])
                                    
                                else:
                                    
                                    noise += abs(spectrums[n][noise_band[0]]) * noise_band_weights[noise_bands.index(noise_band)]
                        
                    elif (trigger_on == False):
                        
                        # If no trigger, set noise to signal and move on
                        
                        noise = signal
                        
                band_ratios[stations.index(station)] = spectrum_band_ratios
                        
            # Sort all the day's triggers chronologically                    
            
            triggers.sort()
            
            # Find the index of the greatest band ratio
            
            onset_times = [[9999, 0] for s in range(len(stations))]
            
            for s in range(len(stations)):
                
                station = stations[s]
                station_band_ratios = band_ratios[s]
                
                try:
                    maxval = max(station_band_ratios)
                except:
                    # Fails when no data exists for a station
                    continue
                
                maxval_idx = station_band_ratios.index(maxval)
                
                # Find the trigger with the earliest start index
                # that contains the max band ratio
                
                for trigger in triggers:
                    
                    if trigger[2] == station:
                        
                        if (trigger[3] <= maxval_idx <= trigger[4]):
                            
                            if trigger[4] < onset_times[s][0]:
                                
                                onset_times[s][0] = trigger[4]
                                onset_times[s][1] = trigger
                            
#                plt.subplot(int(str(len(stations)) + '1' + str(s + 1)))
#                plt.plot(band_ratios[s], color = 'black')
#                plt.axvline(trigger[3], color = 'blue')
#                plt.axvline(trigger[4], color = 'blue')
#                plt.axvline(onset_times[s][1][3], color = 'red')
#                plt.axvline(onset_times[s][1][4], color = 'red')
#                
#                plt.show()
    
            print('Saving detection times')
            
            outfile = open(event_output_directory + event[:-6] + '.csv', 'w')
            outfile = open(event_output_directory + event[:-6] + '.csv', 'a')
    
            for station_trigger in onset_times:
                    if station_trigger[0] != 9999:
                        outfile.write(str(station_trigger[1][2]) + ',' + str(station_trigger[1][0]) + \
                                  ',' + str(station_trigger[1][1]) + '\n')